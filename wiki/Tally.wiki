= Introduction =

Tally is used to keep track of votes or points. At some interval, those votes or points are "swept" by a callback into a runtime data structure. The developer writes the callback to do whatever the product needs - add to NV, write to SOB, etc. The tally is then reset. Runtime totals are pulled from the runtime datasource that was updated by the callback.

= Configuration =

*Tally Server (tool)*
{{{
 ns_section ns/server/${serverName}/module/dci/nt
    ns_param debug 1
 
 ns_section ns/server/${serverName}/module/dci/nt/server
     ns_param backupfile ntData.bak
 
 ns_section ns/server/${serverName}/module/dci/nt/server/clients
     ns_param frontend ${frontendIPAddress}:${frontendRPCPort}
}}}

*Client Server (frontend)*
{{{
ns_section ns/server/${serverName}/module/dci/nt
    ns_param debug 1

 ns_section ns/server/${serverName}/module/dci/nt/client
   ns_param address ${address}
   ns_param port ${rpcPort}
   ns_param max 1000
}}}


= Usage =

To use tally, you have to have a callback loaded on the tool server. Here is a sample tally callback. NOTE: Tally Callbacks must take "key count total" as arguments in that order:
{{{
proc generic.processTallies {key count total} {
    if {[nv.cget tallyTotals ${key}.total oldTotal]} {
        incr total $oldTotal
    }
    if {[nv.cget tallyTotals ${key}.count oldCount]} {
        incr count $oldCount
    }
    nv.set tallyTotals ${key}.total $total
    nv.set tallyTotals ${key}.count $count
}
}}}

Send some votes to the Tally server:

{{{
[neon:~] Michael% telnet 0 <frontend Control Port> 
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
login: 
Password: 

frontend:nscp 1> nt.send foo bar 5 

frontend:nscp 2> nt.send foo dork 1

frontend:nscp 2>exit
}}}

You can dump the tally bucket to get to quick look at what will be processed:

{{{
[neon:~] Michael% telnet 0 <tool/tally Control Port> 
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
login: 
Password: 

tool:nscp 1> nt.dump foo
{dork 1 1} {bar 1 5}
}}}

To process the tallies:

{{{
tool:nscp 2> nt.get foo generic.processTallies
1
}}}

Notice the the runtime data structure has been updated and the tally reset:

{{{
tool:nscp 3> nv.dump tallyTotals
bar.count 1 dork.total 1 bar.total 5 dork.count 1
tool:nscp 4> nt.dump foo

tool:nscp 5> exit
}}}

You can use ns_schedule to schedule the sweep as needed.