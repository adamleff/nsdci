=Cache API=
nsdci/dcicommon/cache.c

==Introduction==
The Cache API provides a mechanism to create size-based and time-based named caches.  The Network Cache Flush API ([NCF]) is used to send cache flush messages.  Together they provide a powerful, high performance cache-messaging service.  The Cache API functions at a very low level and great care should be taken in its use. See the "Usage" and "Best Practices" sections for examples of how to effectively use the Cache API.

==TCL API==

===cache.createEntry===
Creates an entry handle in _cacheName_ identified by _key_.  _newVariable_ is updated with 1 if an entry for the given key already exists. A handle to the entry is returned.

*cache.createEntry* _cacheName key newVariable_

|| *Argument* || *Description* ||
|| _cacheName_ || String. The name of the cache bucket. ||
|| _key_ || String. The key name to be used. ||
|| _newVariable_ || Boolean. 1 if "key" already exists, 0 if not. ||


|| *Return* || * Description* ||
|| {{{String}}} || Success. The handle of the entry. ||
|| {{{TCL_ERROR}}} || Failure. An error occurred. See the server log for more information. ||

{{{
--------------------------------------------------------------------------------
}}}

===cache.createSized===
Creates a named cache, pruned by size. *NOTE:* The Cache API allows the creation of multiple caches of the same name, essentialy overwritting the previous cache causing a memory leak.

*cache.createSized* _cacheName size_

|| *Argument* || *Description* ||
|| _cacheName_ || String. The name of the cache bucket. ||
|| _size_ || Numeric. The size of the bucket in bytes. ||


|| *Return* || * Description* ||
|| {{{NULL}}} || Success. The cache bucket was created. ||
|| {{{TCL_ERROR}}} || Failure. An error occurred. See the server log for more information. ||

{{{
--------------------------------------------------------------------------------
}}}

===cache.createTimed===
Creates a named cache, pruned by time. *NOTE:* The Cache API allows the creation of multiple caches of the same name, essentialy overwritting the previous cache causing a memory leak.

*cache.createSized* _cacheName timeout_

|| *Argument* || *Description* ||
|| _cacheName_ || String. The name of the cache bucket. ||
|| _timeout_ || Integer. The TTL in minutes. ||


|| *Return* || * Description* ||
|| {{{NULL}}} || Success. The cache bucket was created. ||
|| {{{TCL_ERROR}}} || Failure. An error occurred. See the server log for more information. ||

{{{
--------------------------------------------------------------------------------
}}}

===cache.deleteEntry==
Removes an entry from the named cache. *NOTE:* This command does not free the memory associated with the cache entry's value. To delete an entry and free its current value, you must call _cache.flushEntry_.

*cache.deleteEntry* _entry_

|| *Argument* || *Description* ||
|| _entry_ || String. The handle returned by _cache.createEntry_ ||


|| *Return* || * Description* ||
|| {{{NULL}}} || Success. The entry was removed from the named cache. ||
|| {{{TCL_ERROR}}} || Failure. An error occurred. See the server log for more information. ||

{{{
--------------------------------------------------------------------------------
}}}

===cache.findEntry===
Retrieves the entry handle in a named cache for _key_.

===cache.flushEntry===
Deletes an entry from the named cache after first unsetting the current value (if any).

===cache.getValue===

===cache.lock===

===cache.setValue===

===cache.timedWait===

===cache.unlock===

===cache.unsetValue===

==Usage==
The following AOLserver Control Port session is meant to give an overview only. Please see the "Best Practices" section on how to safly use the Cache API.
{{{
    [neon:local/aolserver/etc] Michael% telnet localhost 9900
    Trying 127.0.0.1...
    Connected to localhost.
    Escape character is '^]'.
    login: 
    Password: 

    Welcome to frontend running at /usr/local/aolserver/bin/nsd (pid 628)
    AOLserver/4.5.0 (aolserver4_5) for osx built on Jan  4 2007 at 17:11:28
    CVS Tag: $Name:  $
    frontend:nscp 1> cache.createSized myCache 5000000          

    frontend:nscp 2> cache.lock myCache

    frontend:nscp 3> cache.createEntry myCache foo existsBoolean
    eid0x619088
    frontend:nscp 4> cache.setValue eid0x619088 "my value"

    frontend:nscp 5> cache.unlock myCache

    frontend:nscp 6> cache.findEntry myCache foo
    eid0x619088
    frontend:nscp 7> cache.getValue eid0x619088 returnVar
    1
    frontend:nscp 8> set returnVar
    my value
    frontend:nscp 9> exit

    Goodbye!
    Connection closed by foreign host.
    [neon:local/aolserver/etc] Michael%
}}}

==Best Practices==
Creating a cache entry and setting a value in that entry MUST be made as a single transaction. An exclusion lock is provided to ensure this.  If an error is thrown during this action, the cache would remain locked.  A catch should be used around these actions to ensure proper unwinding of the entry and the lock:
{{{
    if {[catch {
        cache.lock $cacheName
        set entry [cache.createEntry $cacheName $key existsBoolean]
        cache.setValue $entry $value
        cache.unlock $cacheName
    }]} {
        set errorString ${::errorInfo}
        catch {cache.flushEntry $entry}
        catch {cache.unlock $cacheName}
        error $errorString
    }
}}}

Special attention should be paid to when and hown named caches are created.  The Cache API allows the creation of multiple caches of the same name, essentialy overwritting the previous cache causing a memory leak.  Because of this, the safest place for cache creation is at server startup, not in a procedure or page code.

Need to document the BPs for wait, broadcast, and signal